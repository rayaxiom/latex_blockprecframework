//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================

//Include guards
#ifndef OOMPH_SIMPLE_BLOCK_PRECONDITIONERS
#define OOMPH_SIMPLE_BLOCK_PRECONDITIONERS


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// c++ include
#include<list>

// oomph-lib includes
#include "generic.h"

namespace oomph
{
  

//===start_of_simple_block_diagonal_preconditioner_class=======================
/// \short Simple proof-of-concept block diagonal preconditioner for
/// demo purposes. There's a much better version in src/generic!
//=============================================================================
 template<typename MATRIX> 
  class SimpleBlockDiagonalPreconditioner : public BlockPreconditioner<MATRIX>
 {
  
   public :
  
  /// Constructor for SimpleBlockDiagonalPreconditioner
   SimpleBlockDiagonalPreconditioner() : BlockPreconditioner<MATRIX>()
   {
   } // end_of_constructor

 
  /// Destructor - delete the diagonal solvers
  ~SimpleBlockDiagonalPreconditioner()
   {
    // Delete diagonal preconditioners (approximate solvers)
    unsigned n_block = Diagonal_block_preconditioner_pt.size();
    for (unsigned i = 0 ; i < n_block; i++)
     {
      delete Diagonal_block_preconditioner_pt[i];
      Diagonal_block_preconditioner_pt[i] = 0;
     }
   }
     
  /// Broken copy constructor
  SimpleBlockDiagonalPreconditioner(const SimpleBlockDiagonalPreconditioner&) 
  { 
   BrokenCopy::broken_copy("SimpleBlockDiagonalPreconditioner");
  } 
 
  /// Broken assignment operator
  void operator=(const SimpleBlockDiagonalPreconditioner&) 
  {
   BrokenCopy::broken_assign("SimpleBlockDiagonalPreconditioner");
  }
  
  /// Apply preconditioner to r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  virtual void setup();
  
 private :
  
  /// \short Vector of SuperLU preconditioner pointers for storing the 
  /// preconditioners for each diagonal block
  Vector<Preconditioner*> Diagonal_block_preconditioner_pt;

 };


 //==start_of_setup_for_SimpleBlockDiagonalPreconditioner======================
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void SimpleBlockDiagonalPreconditioner<MATRIX>::setup()
 {

  // Set up the block look up scheme
  this->block_setup();

  // Number of blocks
  unsigned nblock_types = this->nblock_types();

  // Resize the storage for the diagonal blocks
  Diagonal_block_preconditioner_pt.resize(nblock_types);

  // Create the subsidiary preconditioners
  for (unsigned i=0;i<nblock_types;i++)
   {
    Diagonal_block_preconditioner_pt[i] = new SuperLUPreconditioner;
   }

  // Set up the subsidiary preconditioners with the diagonal blocks
  for (unsigned i=0;i<nblock_types;i++)
   {
    // Get block
    CRDoubleMatrix block;
    this->get_block(i,i,block);
    
    // Set up preconditioner (i.e. lu-decompose the block)
    Diagonal_block_preconditioner_pt[i]->setup(&block,this->comm_pt());
    
    // Done with this block now, so can go out of scope; LU decomposition
    // is retained in superlu
   }
 }
 
 
 //=============================================================================
 /// Preconditioner solve for the block diagonal preconditioner
 //=============================================================================
 template<typename MATRIX> 
  void SimpleBlockDiagonalPreconditioner<MATRIX>::
  preconditioner_solve(const DoubleVector& r, DoubleVector& z)
  {
   // Split up rhs vector into sub-vectors, re-arranged to match
   // the matrix blocks
   Vector<DoubleVector> block_r;
   this->get_block_vectors(r,block_r);

   // Get number of blocks
   unsigned n_block = this->nblock_types();

   // Solution of block solves
   Vector<DoubleVector> block_z(n_block);
   for (unsigned i = 0; i < n_block; i++)
    {
     Diagonal_block_preconditioner_pt[i]->preconditioner_solve(block_r[i],
                                                               block_z[i]);
    }
   
   // Copy solution in block vectors block_z back to z
   this->return_block_vectors(block_z,z);
  }
 



 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////




}
#endif

