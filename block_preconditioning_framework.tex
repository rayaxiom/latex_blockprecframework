In this document we discuss \verb+oomph-lib+'s block preconditioning
framework. We describe the functionality of the framework by starting with 
discussing the implementation of a simple block diagonal preconditioner, the 
LSC preconditioner, and finally a preconditioner for the 
solution of the constrained Navier-Stokes equations with Lagrange multipliers.

The aim of the block preconditioning framework is to provide a simple 
environment to facilitate the implementation of distributed block 
preconditioners which in particular allows existing (block) preconditioners to 
be reused to create in hierarchical fashion new block preconditioners for 
multi-physics problems. For example, in the Lagrangian preconditioner 
(considered in this document) we reuse the existing LSC preconditioner 
for the subsidiary problems.

\section{ Theoretical Background\label{sec:theoretical_background}}
In \verb+oomph-lib+, all problems are solved by Newton's method,
which requires the repeated solution of linear systems of the form

\begin{equation*}
J\;\mathbf{\delta x} = -\mathbf{r}
\end{equation*}
for the Newton correction $\mathbf{\delta x}$ where $J$ is the
Jacobian matrix and $\mathbf{r}$ is the vector of residuals. (Left) 
preconditioning represents a transformation of the original linear system to
\begin{equation*}
P^{-1}J\;\mathbf{ \delta x}=-P^{-1}\mathbf{r}
\end{equation*}
is introduced with the aim of accelerating the convergence of Krylov subspace 
iterative methods such as GMRES or CG. The application of the preconditioner 
requires the solution of
\begin{equation*}
P\mathbf{z}=\mathbf{y}
\end{equation*}

for $\mathbf{z}$ at each Krylov iteration.

Block preconditioning requires special enumeration schemes for the unknowns 
(equivalent to reordering the linear systems) where all the unknowns 
corresponding to each type of DOF are grouped together and enumerated 
consecutively. This leads to a natural block structure of the linear systems.

For instance, linear elasticity problems[CITE] involve the solid (the nodal positions in the solid domain) degrees of freedom (DOFs). Consider the two-dimensional case, we begin by reordering the linear system to group together the two types of DOF 
\begin{equation*}
\begin{bmatrix}
 S_{xx} & S_{xy} \\
 S_{yx} & S_{yy}
\end{bmatrix}
\begin{bmatrix}
 \mathbf{\delta x_x} \\
 \mathbf{\delta x_y} 
\end{bmatrix}
=
\begin{bmatrix}
 \mathbf{r_x} \\
 \mathbf{r_y}
\end{bmatrix},
\end{equation*}
then the block diagonal preconditiner of the form 
\begin{equation*}
P_{diag}=
\begin{bmatrix}
S_{xx}&     \\
      &S_{yy}
\end{bmatrix}
\end{equation*}
is obtained by omitting the off-diagonal blocks from the Jacobian.

The application of the preconditioner requires the solution of the linear system
\begin{equation*}
\begin{bmatrix}
S_{xx}& \\
      &S_{yy}
\end{bmatrix}
\begin{bmatrix}
\mathbf{z_x}\\
\mathbf{z_y}
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{y_x}\\
\mathbf{y_y}
\end{bmatrix},
\end{equation*}
the two sub-blocks will be solved directly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FRAMEWORK OVERVIEW
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ Framework Overview\label{sec:framework_overview}}
The above example shows that the application of block preconditioners
require several generic steps:
\begin{itemize}
\item The classification of the DOFs.
\item The application of subsidiary preconditioning operators.
\end{itemize}
The following subsections describe how these tasks are performed
within \verb+oomph-lib+'s block preconditioning framework.

%%%% BLOCK PRECONDITIONABLE ELEMENTS
\subsection{Block Preconditionable Elements\label{sec:block_preconditionable_elements}}
The classification of DOFs is implemented at an elemental level. The class \verb+GeneralisedElement+ contains two broken virtual functions that must be re-implemented to label the DOFs with their type. The functions are:

\begin{itemize}
\item \verb+GeneralisedElement::ndof_types()+ must return the number of DOF types associated with an element.
\item \verb+GeneralisedElement::get_dof_numbers_for_unknowns(...)+ must return a list of pairs comprising a map from global equation number to DOF type for all unknowns in the element.
\end{itemize}
These are already implemented for many elements. For instance the two-dimensional FSI channel with leaflet problem has two types of element:
\begin{itemize}
\item \verb+RefineableQTaylorHoodElement<2>+ are the fluid elements. They have three types of DOF; $x$-velocity DOFs are labelled \verb+0+, $y$-velocity DOFs are labelled \verb+1+ and the pressure DOFs are labelled \verb+2+.
\item \verb+FSIHermiteBeamElement+ are the wall elements and have one type of
  DOF (the nodal position) labelled \verb+0+.
\end{itemize}
The linear elasticity elements \verb+MyLinearElasticityElement<DIM>+ are made block-preconditionable with a wrapper
around the element implemented in the driver code:
\lstset{numberfirstline=true,numberstyle=\scriptsize,breaklines=true, numbers=left, stepnumber=2, frame=single,basicstyle=\ttfamily\scriptsize, showstringspaces=false, language=C++}
\lstinputlisting[firstnumber=64,firstline=64, lastline=118]{./code/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc}
Thus, in the \verb+MyLinearElasticityElement<2>+ we have two types of DOF; corresponding to the $x$ and $y$ nodal displacements. They are classified as DOF types \verb+0+ and \verb+1+ respectively.

%%%% DOF TYPES AND BLOCK TYPES
\subsection{DOF types and block types\label{sec:dof_types_and_block_types}}
In the block diagonal preconditioner for the two-dimensional linear elasticity problem, there are two DOF types, there are also two block types. However, in more complicated preconditioners, such as the LSC preconditioner, there are more DOF types than there are block types. Below we describe relationship between elemental DOF type classification, meshes, the block preconditioner DOF types, and block types:
\begin{itemize}
\item \textbf{Elemental DOF type classification}: Each element classifies it's own DOF type in the function \verb+get_dof_numbers_for_unknowns(...)+. In the case of \verb+MyLinearElasticityElement<2>+ elements, the DOF types are classified as \verb+0+ and \verb+1+. For \verb+QTaylorHoodElement<2>+ elements, the DOF types are classified as \verb+0+ and \verb+1+ for the $x$ and $y$-velocities, and \verb+2+ for the pressure $p$. 

\item \textbf{Role of meshes}: Within the block preconditioning framework, each mesh acts as a container for a set of DOF type classifications. All elements in the same mesh MUST return the same \verb+ndof_types()+ value. If two different element types are in the same mesh, and their \verb+ndof_types()+ does indeed return the same number, then their elementtal DOF type classifcations will be treated as the same type. For example, the \verb+QTaylorHoodElement<2>+ classifies the DOF types as follows:
\begin{itemize}
 \item \verb+0+ $x$-velocity
 \item \verb+1+ $y$-velocity
 \item \verb+2+ $p$-pressure
\end{itemize}
If we wish to impose parallel outflow along a boundary, we attach 

\noindent\verb+ImposeParallelOutflowElement<ELEMENT>+, see demo problem: Steady finite-Reynolds-number flow through an iliac bifurcation, these \verb+FaceElement+s classifies the bulk DOF types as follows:
\begin{itemize}
 \item \verb+0+ constrained $x$-velocity
 \item \verb+1+ constrained $y$-velocity
 \item \verb+2+ $L$-Lagrange multiplier
\end{itemize}
Although the \verb+ndof_types()+ for these two different elements are the same, there are clearly six distinct DOF types. To ensure that the block preconditioning framework treats these as different DOF types, we must have two meshes for the two different type of elements. If we put the two elements types in the same mesh, then the block preconditioning framework will not distinguish between the two \verb+0+ elemental DOF types, i.e. $x$-velocity is the same as constrained $x$-velocity. The same applies to elemental DOF types \verb+1+ and \verb+2+. Within the block preconditioning framework, there is a built-in check to throw an error if a mesh passed to the framework contains multiple types of elements. This check can be avoided by setting the optional argument \verb+allow_multiple_element_type_in_mesh+ when calling the function \verb+set_mesh(...)+ to true, in this case, the framework will check if the \verb+ndof_types()+ of all the elements of the same mesh are the same.

\item \textbf{Block preconditioner DOF types}: The different meshes instructs the block preconditioning framework how to order the elemental DOF types (the \verb+ndof_types()+ function provides an offset). For example, consider the above \verb+vmtk+ problem, the first mesh (the bulk mesh) says the first three elemental DOF types are \verb+0+ , \verb+1+ and \verb+2+ (we know that this corresponds to the $x$ and $y$-velocities and pressure). At this stage the offset is \verb+0+ and the block preconditioner DOF types \verb-0+0-, \verb-1+0- and \verb-2+0-. The second mesh (the surface mesh) also has DOF types \verb+0+ , \verb+1 +and \verb+2+, but because it is a different mesh, the offset is now updated to the sum of the \verb+ndof_types()+ of the first element in all previous meshes (hence it is vital that the \verb+ndof_types()+ of all the elements in a single mesh is the same, although the elements types may be different), in this case it is \verb+3+. The DOF types in the block preconditioner for the surface mesh are \verb-0+3- , \verb-1+3- and \verb-2+3- (which we know corresponds to the constrained $x$ and $y$-velocities and the Lagrange multiplier DOF type). It is important to note that the order of the meshes determines the order of the block preconditioner DOF type enumeration. To this end, where the ordering of the block preconditioner DOF types matters (such as the LSC preconditioner), the block preconditioner should handle the ordering of the meshes, the user should use functions such as \verb+set_navier_stokes_mesh(...)+ in the case of the \verb+NavierStokesSchurComplementPreconditioner+. We call the ordering of the preconditioner DOF types, determined by the elemental DOF type ordering and the ordering of the meshes, the \emph{natural ordering} of the preconditioner DOF types. For the above example, the natural ordering of the preconditioner DOF types would be:
\begin{itemize}
 \item \verb+0+ $x$-velocity
 \item \verb+1+ $y$-velocity
 \item \verb+2+ $p$-pressure
 \item \verb+3+ constrained $x$-velocity
 \item \verb+4+ constrained $y$-velocity
 \item \verb+5+ $L$-Lagrange multiplier
\end{itemize}

Note: Each DOF can be classified more than once. If this is the case, then the classification will be the last mesh visited by the block preconditioning framework. This should not be an issue if you do not have discontinuous boundary conditions.

\item \textbf{Block types}: The block types are the blocks of sub-matrices the block preconditioner works with. Block types may contain more than one preconditioner DOF types or be as fine grain as the number of preconditioner DOF types. Note: There can not be more block types than there are preconditioner DOF types. For example, in case of the the LSC preconditioner (in 2D) we have three DOF types ($x$ , $y$-velocities, and pressure), but the preconditioner only distinguishes between velocity and pressure DOF types, thus we have two block types (velocity block and pressure block). The setup of the block types are handled by the function... \verb+block_setup(...)+. The setup of the blocks and DOF types will be discussed in more detail later on.
\end{itemize}


%%%% MASTER AND SUBSIDIARY PRECONDITIONER
\subsection{Master and Subsidiary Preconditioners\label{sec:master_and_subsidiary_preconditioners}}
Consider the again the LSC Navier-Stokes preconditioner.
If we decide to approximate the $\mathbf{F}$ block (the momentum block) by it's diagonal blocks, we can pass the block diagonal preconditioner (discussed in (Distributed) General-Purpose Block Preconditioners) to the LSC preconditioner to use as a subsidiary preconditioner via the function \verb+set_f_preconditioner(...)+. We can do the same with the pressure system with the function \verb+set_p_preconditioner(...)+. We refer to these preconditioners as subsidiary preconditioners. \verb+Oomph-lib+'s block preconditioning framework facilitates the the reuse of existing preconditioners as subsidiary preconditioners.

It is important to note that we do not need to consider the \verb+block structure+ of subsidiary block preconditioners when developing master preconditioners. However, the master preconditioner must be aware of the preconditioner DOF type ordering of the subsidiary preconditioner. For example, if the LSC preconditioner is a subsidiary preconditioner (as is the case of the FSI preconditioner), the FSI preconditioner must ensure that the last DOF type given to the LSC preconditioner is the pressure DOF type, and the ones before that are the velocity DOF types.

There is only one `true' master preconditioner, the rest are all subsidiary preconditioners, each subsidiary preconditioner holds a pointer to the preconditioner one level up in the hierarchy. Say, there are three preconditioners, $P1$, $P2$ and $P3$. If we use $P2$ to solve a subsidiary system in $P1$, and $P3$ to solve a subsidiary system in $P2$, then it could be said that $P1$ is the master preconditioner for $P2$, and $P2$ is a master preconditioner for $P3$. However, because $P2$'s \verb+Master_block_preconditioner_pointer_pt+ is not null, it is automatically classed as a subsidiary preconditioner. Only the true master preconditioner (so that the \verb+Master_block_preconditioner_pt+ is null) holds all the information about the DOF types and look-up schemes. If a subsidiary preconditioner requires information held only by the master preconditioner, it will go to it's `master' preconditioner. If this `master' preconditioner is a subsidiary preconditioner, it will again go up the hierarchy to it's master preconditioner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% USING THE SIMPLE DIAGONAL BLOCK PRECONDITIONER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using the Simple Block Preconditioner\label{sec:using_the_simple_block_preconditioner}}

We begin our discussion of the implementation details by demonstrating how to use the preconditioner (implemented in the class \verb+SimpleBlockDiagonalPreconditioner+) in an actual driver code 

(\verb+two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc+).

In the problem constructor, we construct the solver and preconditioner combination. We specify the GMRES iterative solver, and, if available, use the distributed version implemented in \verb+TrilinosAztecOOSolver+.
\lstset{numberstyle=\scriptsize,breaklines=true, numbers=left, stepnumber=2, frame=single,basicstyle=\ttfamily\scriptsize, showstringspaces=false, language=C++}
\lstinputlisting[firstnumber=348, firstline=348, lastline=361]{./code/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc}
Then we construct an instance of the preconditioner. This linear elasticity problem contains one types of element used for preconditioning (see section \ref{sec:block_preconditionable_elements}). There also exists \verb+LinearElasticityTractionElement+, but in this case the block preconditioner does not require the surface mesh since the bulk mesh contains all the DOFs that needs to be classified and \verb+MyLinearElasticityElement+ does classify all the DOF in the bulk mesh. We store
the different element types in seperate meshes. Only the bulk mesh is passed to the preconditioner. Finally, the preconditioner is passed to the 
solver.
\lstset{numberstyle=\scriptsize,breaklines=true, numbers=left, stepnumber=2, frame=single,basicstyle=\ttfamily\scriptsize, showstringspaces=false, language=C++}
\lstinputlisting[firstnumber=363,firstline=363, lastline=373]{./code/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc}
In the main function,
\lstset{numberstyle=\scriptsize,breaklines=true, numbers=left, stepnumber=2, frame=single,basicstyle=\ttfamily\scriptsize, showstringspaces=false, language=C++}
\lstinputlisting[firstnumber=450,firstline=450, lastline=454]{./code/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc}
we create an instance of the  problem which problem can now be solved in the normal \verb+oomph-lib+ fashion:
\lstset{numberstyle=\scriptsize,breaklines=true, numbers=left, stepnumber=2, frame=single,basicstyle=\ttfamily\scriptsize, showstringspaces=false, language=C++}
\lstinputlisting[firstnumber=466,firstline=466, lastline=480]{./code/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% IMPLEMENTING A BLOCK DIAGONAL PRECONDITIONER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The implementation of a block diagonal preconditioner\label{sec:the_implementation_of_a_block_diagonal_preconditioner}}

We discuss the implementation of a block preconditioner within
\verb+oomph-lib+'s block preconditioning framework. In particular, we will address three fundamental tasks:
\begin{itemize}
\item How to identify and classify the DOFs in the underlying \verb+Problem+.
\item How to extract subsidiary matrix blocks from the full Jacobian.
\item How to recycle existing preconditioning operators within new preconditioners.
\end{itemize}

We implement the block diagonal preconditioner in the
class \verb+SimpleBlockDiagonalPreconditioner+. This class inherits
from the base class \verb+BlockPreconditioner+ which provides the generic 
functionality required for common block preconditioning operations.
\lstset{numberstyle=\scriptsize,breaklines=true, numbers=left, stepnumber=2, frame=single,basicstyle=\ttfamily\scriptsize, showstringspaces=false, language=C++}
\lstinputlisting[firstnumber=53,firstline=53, lastline=55]{./code/simple_block_preconditioners.h}
This preconditioner requires a \verb+Vector+ of pointers to \verb+Preconditioner+s for each diagonal block matrix.
\lstinputlisting[firstnumber=97,firstline=97, lastline=99]{./code/simple_block_preconditioners.h}

%%%% CONSTRUCTOR FOR BLOCK DIAGONAL PRECONDITIONER
\subsection{Constructor for block diagonal preconditioner\label{sec:constructor_for_block_diagonal_preconditioner}}
The constructor is usually used to initialised variables. In this case, there is nothing to initialise.
\lstinputlisting[firstnumber=59,firstline=59, lastline=62]{./code/simple_block_preconditioners.h}

%%%% CONSTRUCTOR FOR BLOCK DIAGONAL PRECONDITIONER
\subsection{setup(...) for block diagonal preconditioner\label{sec:block_diagonal_preconditioner_setup}}

Like all preconditioners, \verb+BlockPreconditioners+ have two key
functions, \verb+setup(...)+ and \verb+preconditioner_solve(...)+ both of which are discussed in more detail in the \verb+oomph-lib+ Linear Solvers Tutorial [CITE]. We begin by considering the function \verb+setup(...)+.
\lstinputlisting[firstnumber=107,firstline=107, lastline=109]{./code/simple_block_preconditioners.h}
At the simplest level, \verb+Meshes+ are just containers for elements. To reiterate section \ref{sec:dof_types_and_block_types}, storing different element type in separate meshes enables the \verb+BlockPreconditioner+ to differentiate between the elemental DOF types of different element types. The order of the meshes determine the order of the preconditioner DOF types.
Therefore, in more sophisticated preconditioners, the preconditioner usually handle the calls to \verb+set_nmesh(...)+ and \verb+set_mesh(...)+ functions. For this simplistic case, the functions \verb+set_nmesh(...)+ and \verb+set_mesh(...)+ were called in the driver code (see section \ref{sec:using_the_simple_block_preconditioner}).

Passing the meshes to \verb+BlockPreconditioner+ gives the framework access to the
meshes and allows the preconditioner write access to the number of DOF types associated with the elements in each mesh.

\subsubsection{block\_setup(...)\label{sec:block_setup}}
The next step is to define a mapping from DOF number to block
number. This preconditioner's block type is as fine grain as the preconditioner DOF types. To see this, recall, if the Jacobian (partitioned into DOF types) takes the form 
\begin{equation*}
J =
\begin{bmatrix}
S_{xx}&S_{xy} \\
S_{yx}&S_{yy}
\end{bmatrix},
\end{equation*}
then the preconditioner is
\begin{equation*}
P_{diag} =
\begin{bmatrix}
S_{xx}& \\
      &S_{yy}
\end{bmatrix}.
\end{equation*}
It is clear that the blocks the preconditioner works with has to be as fine grain as the DOF types. This is achieved by calling the function \verb+block_setup(...)+ with no arguments. By default, this has the same effect as calling \verb+block_setup(...)+ with the identity \verb+dof_to_block_map+ Vector \verb+=+ \verb+[0 1]+.
\lstinputlisting[firstnumber=111,firstline=111, lastline=112]{./code/simple_block_preconditioners.h}

For this simple block diagonal preconditioner, there is method of changing the \verb+dof_to_block_map+ Vector. There exists a more sophisticated version of the block diaginal preconditioner in the class \verb+GeneralPurposeBlockPreconditioner+, where there exists a function

\noindent\verb+set_dof_to_block_map(Vector<unsigned>& dof_to_block_map)+
to change the \verb+dof_to_block_map+ from the default. Subtilties of the \verb+dof_to_block_map+ Vector is discussed below.

\subsubsection{block\_setup(...): Combining DOF types\label{sec:block_setup_combining_dof_types}}
If we want a block type to consist of more than one preconditioner DOF type, then we can provide a \verb+dof_to_block_map+ to the function \verb+block_setup(...)+ describing the mapping we want. For example, if we extend the example above so there are three DOF types,
\begin{equation*}
J =
\begin{bmatrix}
S_{xx}&S_{xy}&S_{xz} \\
S_{yx}&S_{yy}&S_{yz} \\
S_{zx}&S_{zy}&S_{zz}
\end{bmatrix},
\end{equation*}
and instead of simply using the diagonal blocks, we want to use a block preconditioner of the following form
\begin{equation*}
\tilde{P}_{diag} =
\begin{bmatrix}
S_{xx}&S_{xy}&       \\
S_{yx}&S_{yy}&       \\
      &      &S_{zz}
\end{bmatrix}.
\end{equation*}
That is, we want to group the first two preconditioner DOF types as one block type and the last preconditioner DOF type as a separate block type. This is achieved by passing the \verb+dof_to_block_map+ \verb+=+ \verb+[0 0 1]+ to the function \verb+block_setup(...)+, we see a similar \verb+dof_to_block_map+ in the implementation of the LSC preconditioner. It is important to note that although the (in C++ index notation) block (0,0) consists of preconditioner DOF types 
$\displaystyle
\begin{bmatrix}
S_{xx}&S_{xy} \\
S_{yx}&S_{yy} 
\end{bmatrix}
$, it is not gauranteed that the DOF types are grouped in such a manner in the (0,0) block.

\subsubsection{block\_setup(...): Re-ordering DOF types\label{sec:block_setup_reordering_dof_types}}
Continuing from the example above, the natural ordering of the preconditioner DOF types (determined by the ordering of the elemental DOF types and the order of the meshes added to the block preconditioner as decribed in section \ref{sec:dof_types_and_block_types}) is:
\begin{center}
    \begin{tabular}{ | r | c c c |}
    \hline
    DOF type name: & $S_{x}$ & $S_{y}$ & $S_{z}$ \\ 
    Natural ordering: & 0 & 1 & 2 \\ 
    \hline
    \end{tabular}
\end{center}
We have named the DOF types so facilitate the discussion. Suppose we want to re-order the DOF types such that we have the following block order:
\begin{center}
    \begin{tabular}{ | r | c c c |}
    \hline
    New block order: & $S_{z}$ & $S_{x}$ & $S_{y}$ \\ 
    \hline
    \end{tabular}
\end{center}
Then the \verb+dof_to_block_map+ \verb+Vector+ will be
\begin{center}
    \begin{tabular}{ | r | c c c |}
    \hline
    \verb+dof_to_block_map+: & 1 & 2 & 0 \\ 
    \hline
    \end{tabular}
\end{center}
The index of the \verb+dof_to_block_map+ Vector is the DOF type you want to move, then ask yourself `where do I want to move this DOF type to?', put this value into the current position in the \verb+dof_to_block_map+ Vector.

Combining this with the previous concept, it is possible to create a preconditioner of the form
\begin{equation*}
\tilde{P}_{diag} =
\begin{bmatrix}
S_{zz}&S_{zx}&       \\
S_{xz}&S_{xx}&       \\
      &      &S_{yy}
\end{bmatrix}
\end{equation*}
with the \verb+dof_to_block_map+ Vector \verb+[0 1 0]+.

%%%% Set up the subsidiary preconditioners
\subsubsection{Set up subsidiary preconditioners\label{sec:set_up_subsidiary_preconditioners}}
The next step is to set up the subsidiary preconditioners. We use the \verb+SuperLU+ preconditioner for all the subsidiary systems, we require as many subsidiary preconditioners as there are the number of blocks that the block preconditioner is working with. First we create a new instances of the of \verb+SuperLUPreconditioner+ for every block.
\lstinputlisting[firstnumber=114,firstline=114, lastline=124]{./code/simple_block_preconditioners.h}
Now we extract the diagonal blocks and call the \verb+setup(...)+ function of the subsidiary preconditioners.
\lstinputlisting[firstnumber=126,firstline=126, lastline=138]{./code/simple_block_preconditioners.h}

%%%% PRECONDITIONER SOLVE FOR BLOCK DIAGONAL PRECONDITIONER
\subsection{Preconditioner solve for block diagonal preconditioner\label{sec:preconditioner_solve_for_block_diagonal_preconditioner}}
Next we consider the \verb+preconditioner_solve(...)+ function which applies the action of the preconditioner to the input vector $\mathbf{y}$ and returns the result in $\mathbf{z}$.
\lstinputlisting[firstnumber=142,firstline=142, lastline=147]{./code/simple_block_preconditioners.h}
In this section, we implement the application of the preconditioner as described in the section \ref{sec:theoretical_background}. First we split the rhs vector into sub-vectors, re-arranged to match the block order of the preconditioner blocks.
\lstinputlisting[firstnumber=149,firstline=149, lastline=152]{./code/simple_block_preconditioners.h}
Next we loop through the LU decompositions stored in the \verb+Diagonal_block_preconditioner_pt+, and apply the subsidiary preconditioners.
\lstinputlisting[firstnumber=157,firstline=157, lastline=163]{./code/simple_block_preconditioners.h}
Finally we return the solution back into $\mathbf{z}$ in the correct DOF order.
\lstinputlisting[firstnumber=165,firstline=165, lastline=166]{./code/simple_block_preconditioners.h}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LSC BLOCK PRECONDITIONER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LSC block preconditioner\label{sec:lsc_block_preconditioner}}
Theoretical dicussion of the LSC preconditioner can be found in "Finite Elements and Fast Iterative Solvers with Applications in Incompressible Fluid 
Dynamics" by Howard C. Elman, David J. Silvester, and Andrew J. Wathen,
published by Oxford University Press, 2006.

In this section, we partially follow the \verb+oomph-lib+ LSC tutorial [CITE oomph-lib lsc tutorial], where we take a closer look at the implementation details to address the following concepts:
\begin{itemize}
\item Non trivial grouping of preconditioner DOF types into block types.
\item Setting up \verb+MatrixVectorProduct+s within the block preconditioning framework.
\item Subsidiary block preconditioners:
 \begin{itemize}
 \item The \verb+dof_map+ for the \verb+turn_into_subsidiary_block_preconditioner(...)+ function.
 \item Modification to the \verb+preconditioner_solve(...)+ function.
 \end{itemize}
\end{itemize}

%%%% LSC theory
\subsection{Theory\label{sec:lsc_theory}}
\verb+oomph-lib+ currently provides two types of (LBB-stable)
Navier-Stokes elements: Taylor-Hood (Q2Q1) and Crouzeix-Raviart
(Q2Q-1) elements. These contain two distinct types of degrees of freedom,
namely the velocities and pressures.

The least-squares commutator (LSC; formerly BFBT) Navier-Stokes 
preconditioner employs \verb+oomph-lib+'s block-preconditioning framework
to (formally) re-order the linear system to be solved during the
Newton iteration into 2x2 blocks, corresponding to the velocity 
and pressure unknowns. We note that all velocity components are 
treated as a single block of unknowns. The linear system
therefore has the following block structure
\begin{equation*}
\begin{bmatrix}
{\bf F} & {\bf G} \\ {\bf D} & {\bf 0} 
\end{bmatrix}
\begin{bmatrix}
{\bf z}_u \\ {\bf z}_p
\end{bmatrix} 
 =
\begin{bmatrix}
{\bf r}_u \\ {\bf r}_p
\end{bmatrix} 
.
\end{equation*}
Here $\mathbf{F}$ is the momentum block, $\mathbf{G}$ the
discrete gradient operator, and $\mathbf{D}$ the discrete
divergence operator. (For unstabilised elements, we have 
$\mathbf{D} = \mathbf{G}^T$ and in much of the literature
the divergence matrix is denoted by $\mathbf{B}$.)

An "exact" preconditioner would solve this system exactly and thus
ensure the convergence of any iterative linear solver in a single 
iteration. However, the application of such a preconditioner
would, of course, be exactly as expensive as a direct solve.
The LSC/BFBT preconditioner replaces the exact Jacobian by 
a block-triangular approximation
\begin{equation*}
\begin{bmatrix}
{\bf F} & {\bf G} \\ {\bf 0} & -{\bf M}_s 
\end{bmatrix} 
\begin{bmatrix}
{\bf z}_u \\ {\bf z}_p
\end{bmatrix} 
=
\begin{bmatrix}
{\bf r}_u \\ {\bf r}_p
\end{bmatrix}
,
\end{equation*}
where $\mathbf{M}_s$ is an approximation to the pressure 
Schur-complement $\mathbf{S}=\mathbf{D} \mathbf{F}^{-1}\mathbf{G}$.
This system can be solved in two steps:
\begin{enumerate}
\item Solve the second row for $\mathbf{z}_p$ via
   \begin{equation*}
   \mathbf{z}_p = - \mathbf{M}_s^{-1} \mathbf{r}_p
   \end{equation*}
\item Given $\mathbf{ z}_p$, solve the first row for $\mathbf{z}_u$ via
   \begin{equation*}
   \mathbf{z}_u = \mathbf{F}^{-1} \left( \mathbf{r}_u - \mathbf{G} \mathbf{z}_p \right)
   \end{equation*}
\end{enumerate}
In the LSC/BFBT preconditioner, the action of the inverse pressure
Schur complement 
\begin{equation*}
\mathbf{z}_p = - \mathbf{M}_s^{-1} \mathbf{r}_p
\end{equation*}
is approximated by
\begin{equation*}
\mathbf{z}_p = - 
\big(\mathbf{D} \widehat{\mathbf Q}^{-1}{\mathbf G} \big)^{-1}
\big({\mathbf D} \widehat{\mathbf Q}^{-1}{\mathbf F} \widehat{\mathbf Q}^{-1}{\mathbf G}\big) 
\big({\mathbf D} \widehat{\mathbf Q}^{-1}{\mathbf G} \big)^{-1}
{\mathbf r}_p,
\end{equation*}
where  $ \widehat{\mathbf Q}$ is the diagonal of the velocity
mass matrix. The evaluation of this expression involves
two linear solves involving the matrix
\begin{equation*}
{\mathbf P} = \big({\mathbf D} \widehat{\mathbf Q}^{-1}{\mathbf G} \big)
\end{equation*}
which has the character of a matrix arising from the discretisation 
of a Poisson problem on the pressure space. We also have
to evaluate matrix-vector products with the matrix 
\begin{equation*}
{\mathbf E}={\mathbf D}\widehat{\mathbf Q}^{-1}{\mathbf F}\widehat{\mathbf Q}^{-1}{\mathbf G}
\end{equation*}
In our implementation of the preconditioner, the linear systems
can either be solved "exactly", using \verb+SuperLU+ (in its incarnation
as an exact preconditioner; this is the default) or by any 
other \verb+Preconditioner+ (interpreted as an "inexact solver")
specified via the access functions
\begin{verbatim}
NavierStokesSchurComplementPreconditioner::set_f_preconditioner(...)
\end{verbatim}
or 
\begin{verbatim}
NavierStokesSchurComplementPreconditioner::set_p_preconditioner(...)
\end{verbatim}

%%%% Implementation details
\subsection{Implementation\label{sec:lsc_implementation}}
In this section we focus on aspect of the implementation relevant to the 
discussion of the block preconditioning framework.
Let \verb+dim+ be the spatial dimension of the problem, then \verb+NavierStokesSchurComplementPreconditioner+ expects 
\verb+dim+ + 1 preconditioner DOF types, \verb+dim+ number of DOF types corresponds to the velocity DOF types and 1 DOF type for the pressure. 

\subsubsection{setup(...) for the LSC preconditioner\label{sec:lsc_implementation_setup}}
We need to group the velocity DOF types as one block type and the pressure DOF type as one DOF type. This is achieved by setting the first \verb+dim+ entries of the \verb+dof_to_block_map+ Vector to 0 and the last entry to 1.
\lstinputlisting[firstnumber=235,firstline=235, lastline=238]{./code/navier_stokes_preconditioners.cc}
For example, in two dimensions, the natural ordering of the DOF types and the \verb+dof_to_block_map+ Vector is given below.
\begin{center}
    \begin{tabular}{ | r | c c c |}
    \hline
    DOF type name: & $u$ & $v$ & $p$ \\ 
    Natural ordering: & 0 & 1 & 2 \\ 
    \verb+dof_to_block_map+: & 0 & 0 & 1 \\ 
    \hline
    \end{tabular}
\end{center}


The implementation follows the theory in section \ref{sec:lsc_theory}. We highlight important points to note when implementing a new preconditioner. 


When setting up a \verb+MatrixVectorProduct+, it is important to use the setup function \verb+setup_matrix_vector_product(...)+. The first argument is a pointer to the \verb+MatrixVectorProduct+, the second is a pointer to the matrix we wish to set up with, the third is an unsinged value indicating the block vector which the matrix needs to be multiplied by. This ensures that the column distribution of the \verb+MatrixVectorProduct+ is set up properly.
\lstinputlisting[firstnumber=493,firstline=493, lastline=494]{./code/navier_stokes_preconditioners.cc}

If the $\mathbf{F}$ preconditioner is a block preconditioner (used to solve the system $\mathbf{z}_u = \mathbf{F}^{-1} \left( \mathbf{r}_u - \mathbf{G} \mathbf{z}_p \right)$), then we must call the function 

\noindent\verb+turn_into_subsidiary_block_preconditioner(...)+ of the $\mathbf{F}$ preconditioner. This function takes the pointer of the `master' preconditioner (in this sense, master is just one level higher in the block preconditioning framework hierarchy), and a Vector describing a mapping of preconditioner DOF types of the master preconditioner and the subsidiary preconditioner. Then the \verb+setup(...)+ function of the subsidiary preconditioner is called with a pointer to the whole jacobian (via the access function \verb+matrix_pt()+). If the $\mathbf{F}$ preconditioner is not a block preconditioner, then we do the same as we did in the simple block diagonal preconditioner case.
\lstinputlisting[firstnumber=577,firstline=577, lastline=596]{./code/navier_stokes_preconditioners.cc}
The \verb+dof_map+ Vector is different from the \verb+dof_to_block_map+ Vector. The \verb+dof_to_block_map+ Vector describes the mapping of the preconditioner DOF types to block types within the same block preconditioner, as such, this Vector must have the same size as the number of DOF types the preconditioner expects to be working with. The \verb+dof_map+ Vector describes the mapping between the DOF types of a master preconditioner with it's subsidiary preconditioner. Re-ordering DOF types of the subsidiary preconditioner using the \verb+dof_map+ Vector is possible and will be demonstrated in the implementation of the Lagrangian preconditioner discussed later in this document.


\subsubsection{preconditioner\_solve(...) for the LSC preconditioner\label{sec:lsc_implementation_precsolve}}
The \verb+preconditioner_solve(...)+ function for the LSC preconditioner follows the theory discussed in section \ref{sec:lsc_theory}. When block preconditioner are used as subsidiary preconditioners, we DO NOT return the block vector, as this is handled by the subsidiary block preconditioner.
\lstinputlisting[firstnumber=785,firstline=785, lastline=796]{./code/navier_stokes_preconditioners.cc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LAGRANGIAN BLOCK PRECONDITIONER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lagrangian block preconditioner\label{sec:lagrangian_block_preconditioner}}
In this section, we use the implementation of the Lagrangian preconditioner to address the following concepts:
\begin{itemize}
\item Non-trivial re-ordering of block types.
\item Non-trivial re-ordering of subsidiary DOF types.
\item Set precomputed preconditioner blocks for subsidiary block preconditioners.
\end{itemize}
As with previous examples, we highlight the key concepts and neglect the finer implementation details of the preconditioner for the specific problem. The code is (as always) well documented and can be worked through with the theory at hand.
%%%% LSC theory
\subsection{Theory\label{sec:lgr_theory}}
Suppose we want to impose parallel outflow along a boundary, we attach the block preconditionable elements \verb+ImposeParallelOutflowElement+ along the said boundary as discussed in section \ref{sec:dof_types_and_block_types}. This will result in a jacobian of the following block form (partitioned by DOF types):
\renewcommand{\arraystretch}{1.2}
\begin{equation}
\newcommand*{\temp}{\multicolumn{1}{r|}{}}
\left[
\begin{array}{cccccccc}
F_{xx}&F_{xy}&F_{x\hat{x}}&F_{x\hat{y}}& \temp &(B_x)^T&\temp & \\ 
F_{yx}&F_{yy}&F_{y\hat{x}}&F_{y\hat{y}}& \temp &(B_{y})^T&\temp & \\
F_{\hat{x}x}&F_{\hat{x}y}&F_{\hat{x}\hat{x}}&F_{\hat{x}\hat{y}}& \temp &(B_{\hat{x}})^T&\temp & M_x\\
F_{\hat{y}x}&F_{\hat{y}y}&F_{\hat{y}\hat{x}}&F_{\hat{y}\hat{y}}& \temp &(B_{\hat{y}})^T&\temp &M_y \\ 
  \cline{1-7}
B_x&B_{y} &B_{\hat{x}} &B_{\hat{y}} & \temp &  &\temp & \\ 
  \cline{1-8}
  & & M_x & M_y&       &  &\temp & \\
\end{array}
\right]
\left[
\begin{array}{c}
\delta \bar{u}_x \\
\delta \bar{u}_y \\
\delta \bar{u}_{\hat{x}} \\
\delta \bar{u}_{\hat{y}} \\
\delta \bar{p} \\
\delta \bar{l} \\
\end{array}
\right]
=
\left[
\begin{array}{c}
\delta \bar{r}_x \\
\delta \bar{r}_y \\
\delta \bar{r}_{\hat{x}} \\
\delta \bar{r}_{\hat{y}} \\
\delta \bar{r}_p \\
\delta \bar{r}_l \\
\end{array}
\right],
\end{equation}
\renewcommand{\arraystretch}{1}
where the block vector $[\bar{u}_x \, \bar{u}_{\hat{x}}]^T$ contains the $x$ coordinates of the unknown nodal positions. Similarly, the block vector $[\bar{u}_y \, \bar{u}_{\hat{y}}]^T$ contains the $x$ coordinates of the unknown nodal positions. The hat represents the nodes affected by the Lagrange multuplier constraint. The Lagrange multiplier block takes the form
\begin{equation*}
	L =
\begin{bmatrix}
 O & O & M_x & M_y & O \\
\end{bmatrix}.
\end{equation*}
For simplicity, we can re-write the jacobian as
\begin{equation*}
	\mathcal{J} = 
	\begin{bmatrix}
	 \mathcal{F} & L\\
	L & \mathit{O}
	\end{bmatrix}
\end{equation*}
For this saddle point problem, we seek an augmented preconditioner of the form
\begin{equation*}
	\mathcal{P} = 
	\begin{bmatrix}
	 \mathcal{F}+ L^T W^{-1} L & \mathit{O}\\
	\mathit{O} & W
	\end{bmatrix}
\end{equation*}
The matrix $W\in \mathbb{R}^{n_l \times n_l}$ is chosen to be
 \begin{equation}
 	W = 
 	\begin{bmatrix}
 	\frac{1}{\sigma}L L^T
 	\end{bmatrix},
 	\label{eq:W}
 \end{equation}
to preserve the sparsity of $\mathcal{F}$ and $\sigma$ is chosen to be the norm of the momentum block to be an effective preconditioner for the above saddle point problem. Application of this preconditioner requires the solution of the two diagonal blocks. We can further approximate the augmented $\hat{\mathcal{F}} = \mathcal{F} + L^TW^{-1}L$ block by the LSC approximation, this is facilitated by the re-use of block preconditioners in \verb+oomph-lib+'s block preconditioning framework.

Detailed theoretical discussion for the Lagrangian preconditioner can be found in [CITE some chapter in my thesis or the yet to be published paper].
%%%% Implementation details
\subsection{Implementation\label{sec:lgr_implementation}}

The Lagrangian preconditioner takes the `bulk' mesh as the first mesh (the mesh containing the TaylorHood elements). Subsequent meshes are surfaces meshes containing the \verb+ImposeParallelOutflowElement+ elements. We have established in section \ref{sec:dof_types_and_block_types} that this leads to the natural DOF type ordering
\begin{center}
    \begin{tabular}{ | r | c c c c c c |}
    \hline
    DOF type name:    & $u$ & $v$ & $p$ & $u_c$ & $v_c$ & $L$ \\ 
    Natural ordering: & 0   &  1  &  2  &   3   &   4   &  5  \\ 
    \hline
    \end{tabular}
\end{center}
Where $u$ and $v$ are the `bulk' velocity DOF types in the $x$ and $y$ direction, $u_c$ and $v_c$ are the constained velocity DOF types in the $x$ and $y$ direction DOF type, $p$ is the pressure DOF type and $L$ is the lagrange multiplier DOF type. 


 \subsubsection{setup(...) for the Lagrangian preconditioner\label{sec:lgr_setup}}
First we need to create the \verb+dof_to_block_map+ to create the block ordering as observed in section \ref{sec:lgr_theory}. Recall from \ref{sec:dof_types_and_block_types} that to re-order block types, we ask ourselves `where do I want to move this DOF type to?'. This leads to the following \verb+dof_to_block_map+:
\begin{center}
    \begin{tabular}{ | r | c c c c c c |}
    \hline
    DOF type name:      & $u$ & $v$ & $p$ & $u_c$  & $v_c$ & $L$ \\ 
    Natural ordering:   & 0   &  1  &  2  &   3    &   4   &  5  \\ 
Desired block ordering: & $u$ & $v$ & $u_c$ & $v_c$& $p$   & $L$ \\ 
\verb+dof_to_block_map+:& 0   &  1  &  4  &   2    &   3   &  5  \\
    \hline
    \end{tabular}
\end{center}
The creation of the \verb+dof_to_block_map+ Vector is generalised to multiple surface meshes in the \verb+setup(...)+ function of the \verb+LagrangeEnforcedflowPreconditioner+ class.
\lstinputlisting[firstnumber=1078,firstline=1078, lastline=1101]{./code/lagrange_enforced_flow_preconditioner.h}


Suppose want to use the LSC block preconditioner to approximate the $\hat{mathcal{F}}$. First we need to create the \verb+dof_map+ which describes which DOF types from the Lagrangian preconditioner the LSC preconditioner works with. We have to work with the DOF types from the natural order and ask ourselves `which DOF type from the master preconditioner do I want o move into this position?'. The \verb+dof_map+ for this problem is given below, along with the \verb+dof_to_block_map+ for comparison.
\begin{center}
    \begin{tabular}{ | r | c c c c c c |}
    \hline
    DOF type name:      & $u$ & $v$ & $p$ & $u_c$  & $v_c$ & $L$ \\ 
    Natural ordering:   & 0   &  1  &  2  &   3    &   4   &  5  \\ 
Desired block ordering: & $u$ & $v$ & $u_c$ & $v_c$& $p$   & $L$ \\ 
\verb+dof_to_block_map+:& 0   &  1  &  4  &   2    &   3   &  5  \\
\verb+dof_map+:         & 0   &  1  &  3  &   4    &   2   &     \\
    \hline
    \end{tabular}
\end{center}
For the \verb+LagrangeEnforcedflowPreconditioner+, the \verb+dof_map+ generation is generalised to work with multiple surface meshes.
\lstinputlisting[firstnumber=1003,firstline=1003, lastline=1034]{./code/lagrange_enforced_flow_preconditioner.h}
The above code actually generates the list \verb+[0 1 3 4 2 5]+, where the first \verb+dim*nmesh+ entries corresponds to the $\mathcal{F}$ DOF types. Therefore we fill the \verb+dof_map+ with only the required DOF types.
\lstinputlisting[firstnumber=1704,firstline=1704, lastline=1708]{./code/lagrange_enforced_flow_preconditioner.h}
Then we proceed to call the \verb+turn_into_subsidiary_block_preconditioner(...)+ function
\lstinputlisting[firstnumber=1733,firstline=1733, lastline=1735]{./code/lagrange_enforced_flow_preconditioner.h}



There exists two problems if we want to re-use the LSC block preconditioner:
\begin{enumerate}
\item The LSC preconditioner expects \verb+dim+ + 1 DOF types. We our Navier-Stokes block consists of \verb+dim*nmesh+ + 1 DOF types.
\item The function \verb+get_block(...)+ extracts the block matrix from the original jacobian. We want the LSC preconditioner to operate on the modified $\hat{\mathcal{F}}$ block.
\end{enumerate}
There exists one function to solve both problems. The function \verb+set_precomputed_blocks(...)+ takes a \verb+DenseMatrix+ consisting of pointers to the (possibly modified) precomputed preconditioner blocks and (yet another!) mapping (\verb+dof_to_dof_map+) between the DOF types of the master preconditioner and the subsidiary preconditioner. This mapping describes which DOF type of the master preconditioner should be treated as a single DOF type in the subsidiary preconditioner.
For the above example, the \verb+dof_to_dof_map+ Vector would be the two dimension Vector:
\begin{verbatim}
0 [0 2]
1 [1 3]
2 [4]
\end{verbatim}
Recall that we now have the DOF type ordering
\begin{center}
    \begin{tabular}{ | r | c c c c c c |}
    \hline
                        & 0   &  1  &  2  &   3    &   4   &  5  \\ 
Desired block ordering: & $u$ & $v$ & $u_c$ & $v_c$& $p$   & $L$ \\ 
    \hline
    \end{tabular}
\end{center}
so the \verb+dof_to_dof_map+ says to the LSC preconditioner `treat DOF types 0 and 2 from the master preconditioner as DOF type 0, treat the DOF types 1 and 3 from the master preconditioner as DOF type 1, and treat DOF type 4 from the master preconditioner as DOF type 2'. Again, the implementation of the \verb+LagrangeEnforcedflowPreconditioner+ is fully generalised, but will produce the above results.

In the below code, we fill the \verb+f_subblock_pt+ with the (modified) velocity blocks and the rest of the pressure block $B$ to form the blocks required for $\hat{\mathcal{F}}$.
\lstinputlisting[firstnumber=1674,firstline=1674, lastline=1702]{./code/lagrange_enforced_flow_preconditioner.h}
The code below describes how we create the \verb+dof_to_dof_map+.
\lstinputlisting[firstnumber=1747,firstline=1747, lastline=1767]{./code/lagrange_enforced_flow_preconditioner.h}
Now, we set the precomputed blocks and call \verb+setup(...)+.
\lstinputlisting[firstnumber=1769,firstline=1769, lastline=1773]{./code/lagrange_enforced_flow_preconditioner.h}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Source files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Source Files\label{sec:source_files}}
The following source files were used for our discussion of \verb+oomph-lib+'s block preconditioning framework.

\noindent
{\scriptsize
\verb+demo_drivers/linear_solvers/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc+
}

\noindent
{\scriptsize
\verb+demo_drivers/linear_solvers/simple_block_preconditioners.h+
}

\noindent
{\scriptsize
\verb+src/navier_stokes/navier_stokes_preconditioners.h+
}

\noindent
{\scriptsize
\verb+src/navier_stokes/navier_stokes_preconditioners.cc+
}

\noindent
{\scriptsize
\verb+src/navier_stokes/lagrange_enforced_flow_preconditioner.h+
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Source files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Under the hood\label{sec:under_the_hood}}
In this section we take a closer look at innards of the block preconditioning framework. In particular, the mechanism for setting precomputed preconditioner blocks. This feature was developed to allow the re-use of block preconditioners when the master preconditioner has modified the preconditioner blocks. This knowledge is not required for developing new preconditioners, but it may be useful for maintaining the block preconditioning framework.

The following discussion assumes good knowledge of the distributed data structures used within \verb+oomph-lib+, in particular, how data is distributed. If you are not already familiar with these concepts, please refer to the \verb+oomph-lib+ tutorials `Parallel processing' and `Distributed Linear Algebra infrastructure'.

\texttt{Block\-Preconditioner}s are \texttt{Distributed\-Linear\-Algebra\-Object}s. Their \texttt{Linear\-Algebra\-Distribution} can be accessed via the function \texttt{preconditioner\-\_matrix\-\_distribution\-\_pt()}. This \texttt{Linear\-Algebra\-Distribution} describes the distribution of the preconditioner, which is the concatenation of inidividual block distributions \emph{without communication}.

The concatenation of \texttt{Distributed\-Linear\-Algebra\-Object}s without communication means to `combine' several objects (of the same type) into a new object whilst keeping the data on the processor it already resides. For reference, see the following functions:
\begin{itemize}
\item \texttt{CRDoubleMatrixHelpers::concatenate\_without\_communication(...)}
\item \texttt{DoubleVectorHelpers::concatenate\_without\_communication(...)}
\item \texttt{LinearAlgebraDistributionHelpers::concatenate(...)}
\end{itemize}

The distributions of the inidividual preconditioner blocks are uniformly distributed. However, the distribution of the preconditioner (which is a concatenation of the distributions of it's preconditioner blocks) is not uniformly distributed. This means one cannot generate a uniformly distributed matrix and use it as a preconditioner within a particular preconditioner, since the preconditioner expects the preconditioner matrix to have the same distribution as the concatenation of the distributions of the individual preconditioner blocks.

The distribution of the individual preconditioner blocks is stored within each block preconditioner and can be accessed via the function \texttt{block\-\_distribution\-\_pt(...)}.

\subsection{Setting precomputed preconditioner blocks\label{sec:setting_precomputed_preconditioner_blocks}}

We revisit the Lagrangian block preconditioner example discussed in section \ref{sec:lagrangian_block_preconditioner} and assume we have a two dimensional problem with one bulk mesh containing \texttt{QTaylor\-Hood\-Element}s and one surface mesh containing \texttt{Impose\-Parallel\-Outflow\-Element}s. After re-ordering the block types as discribed in section \ref{sec:lgr_implementation}, we have the following block order:
\begin{center}
    \begin{tabular}{ | r | c c c c c c |}
    \hline
                        & 0   &  1  &  2  &   3    &   4   &  5  \\ 
Desired block ordering: & $u$ & $v$ & $u_c$ & $v_c$& $p$   & $L$ \\ 
    \hline
    \end{tabular}
\end{center}
The blocks corresponding to the constrained velocities, namely blocks (2,2), (2,3), (3,2) and (3,3) have been modified by the Lagrangian preconditioner. We want to apply the LSC preconditioner to the (modified) Navier-Stokes blocks 0-4, so we pass pointers to these blocks to the LSC preconditioner.

Within the LSC preconditioner (which splits the block types into velocity and pressure), when we call \texttt{get\-\_block(0,0)}, the preconditioning framework would know that preconditioner blocks have been precomputed and will return a concatenation (without communication) of the following blocks
\begin{equation*}
\begin{bmatrix}
(0,0) & (0,2) & (0,1) & (0,3) \\
(2,0) & (2,2) & (2,1) & (2,3) \\
(1,0) & (1,2) & (1,1) & (1,3) \\
(3,0) & (3,2) & (3,1) & (3,3)
\end{bmatrix}.
\end{equation*}
Since the concatenation is without communication, the distribution of the resuling block(0,0) is not uniform. But the inidivual blocks of a preconditioner always have a uniform distribution! More importantly, this mean that the block vector 0 from the LSC preconditioner also have a uniform distribution, so we cannot use the above preconditioner block since it's distribution is different from that of the vector we with to apply the matrix operation to.

We ensure that the distribution of the preconditioner block matrix is the same as the distribution of the vector we wish to apply the matrix to by the following method: If preconditioner blocks have been precomputed then
\begin{itemize}
\item use the identity \texttt{dof\-\_to\-\_block\-\_map} for the \texttt{bloc\-k\_setup(...)} function.
\item when the function \texttt{get\-\_block(...)} is called, use the lookup scheme set by \texttt{dof\-\_to\-\_dof\-\_map} to concatenate the relevant \emph{precomputed} preconditioner blocks (without communication).
\item when the function \texttt{get\-\_block\-\_vector(...)} is called, use the lookup scheme set by \texttt{dof\-\_to\-\_dof\-\_map} to extract the relevant block vector and concatenate  them (without communication).
\item when the function \texttt{return\-\_block\-\_vector(...)} is called, split the vector into the relevant block vectors and return each block vector back to the vector we wish to return the entries to.
\end{itemize}
As long as the precomputed preconditioner blocks are ordered in the same manner as the underlaying blocks of the LSC preconditioner (the subsidiary preconditioner), then the distribution is the same for the concatenated precomputed block and the concatenated block vectors. The order of the underlaying blocks of the subsidiary preconditioner is determined by the \texttt{dof\-\_map} vector passed to the function \texttt{turn\-\_into\-\_subsidiary\-\_block\-\_preconditioner(...)}.

This scheme has a few subtitles:
\begin{itemize}
\item If preconditioner blocks have been precomputed for a preconditioner, then the number of block types for the preconditioner is the most fine grain. This means that the number of preconditioner DOF types equal to the number of block types.
\item The function \texttt{nblock\-\_types(...)} still returns the number of block types the preconditioner expects without precomputed preconditioner blocks.
\item The function \texttt{ndof\-\_types(...)} still returns the number of DOF types the preconditioner expects without precomputed preconditioner blocks.
\end{itemize}

\subsection{Limitations and future development\label{sec:limitations_and_future_development}}
There is no mechanism to split a matrix which has been concatenated (with or without communication). This means, if the LSC preconditioner was to modify it's preconditioner blocks (having already been set precomputed preconditioner blocks from a master preconditioner), there is no way (yet!) to split up the matrices into the most fine grain block type to pass them down to a another subsidiary preconditioner. The current scheme only allows for one preconditioner in the \emph{hierarchical chain} to modify the preconditioner blocks and pass them down to subsidiary block preconditioners. Two subsidiary block preconditioners can modify the preconditioner blocks and pass them down to it's own subsidiary preconditioner(s) if they are operating on completely different subsidiary systems.

There exists another approach to the whole problem. When the preconditioner blocks are modified by the master preconditioner and to be used by a subsidiary block  preconditioner, the master preconditioner copies the enteries back into a copy of the jacobian. Thus we do not have to concatenate the precomputed block matrices nor do we have to always work with the most fine grain block type. Implementation of this feature was considered but due to time constraints, was not implemented; there is currently no book keeping information of where the DOF came from and there would still be the problem of combining DOF types in the subsidiary preconditioner.

\newpage

%
%\begin{equation}
%P_{NS} = 
%\begin{bmatrix}
% F & B^T \\
%\mathit{O} & -M_S
%\end{bmatrix}.
%\label{eq:NSgeneralprec}
%\end{equation}


